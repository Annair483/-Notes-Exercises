#  js 基础

## 基本语法

js书写位置

```
script[src][type=“text/javascript”]若不存在src属性，则可以在内部书写js代码
a[href="javascript:js代码;"]
```

注释   //单行注释   /**/多行注释

声明变量及赋值

```
声明变量通过关键字var   var fruit；
对变量进行赋值，通过=		fruit = "apple";
var fruit = "apple";
```

## 数据类型

基本数据类型

```
number	==》	数字、NaN
string	==》	有引号的值都是字符串
boolean	==》	true、false
```

特殊数据类型

```
null 空对象
undefined 声明变量但未赋值		报错：** is not defined 变量未声明
```

引用数据类型

```
Object、Array
```

基本数据类型的转换

​	直接转换

```
					 Number("")     ==> 0
Number()	==》		Number("12")    ==> 12
					 Number("aa")  ==>NaN
					 
String()	==》		直接在值两边加上引号

Boolean()	==》		除了0、NaN、“”、null、undefined会转成false，其他都会转成true
```

​	隐式转换

```
1.当运算无法进行下去，需要隐式转换，尝试进行运算
2.尝试运算不成功，会返回NaN
```

数据类型的判断 typeof()

```
typeof(1)   		//number
typeof(NaN)  		//number
typeof("ang")   	//string
typeof(true) 		//boolean
typeof(false) 		//boolean
typeof(null)  		//object
typeof(undefined)  	//undefined
```

## 输出

1. alert(具体的值||变量不加引号)   弹窗输出
2. document.write()    输出到body里面，支持标签
3. console.log() 打印到控制台，用于调试
4. **.innerHTML = ""    

## 运算

算术运算 + - * / %，	若+号一侧有字符串，则代表字符串拼接

关系运算，返回布尔值

```
	1.>  <   >=  <=	允许隐式转换
	2.==  判断两侧的值是否相等（允许隐式转换）
	3.=== 全等于，判断两侧的值以及类型是否相等
	比较规则：
		1. 数字和数字比较, 直接比较大小
		2. 数字和字符串比较, 字符串转换为数字后再比较
		3. 字符串和字符串比较, 进行字符的ASCII码值比较
```

逻辑运算

```
与运算		   两侧条件返回值都为true，返回true
&&	==》		false && 这里的代码不被执行
			 true && 1 ===>1

或运算		   两侧条件返回值都为false，才返回false
||	==》		true || 这里的代码不被执行
			 false || 1    ==>1

! 	==》		取反

&&运算优先级> ||
```

一元运算

```
			++a		先对变量a进行加一运算，再将a的新值返回出去
++	==》		
			a++		先将a的值返回出去，再对变量a进行加一运算		
			
--	==》		同上

对变量进行自增或自减
```

三元运算（双分支语句）

```
条件?满足条件执行这里的代码：不满足条件执行这里的代码
```

运算的优先级

```
1.一元运算 ++ --  ！
2.算术运算
3.关系运算	==》		> < >= <=
					=== ==
					
4.逻辑运算	==》		&&
					||
	
5.赋值运算

6.	,
```

## 常用的数学方法

```
数字.toFixed(n位小数)
Math.random() 获取0-1的随机数，包含0，不包含1
Math.round() 四舍五入
parseInt() 取整
parseFloat() 取浮点数
```

## 进制

```
二进制 0b010101
八进制 0o70134
十进制
十六进制 0xf34434a
转换：
	多进制转十进制		==》parseInt("n进制数","n进制")
	十进制转多进制		==》数字.tostring(n进制)
```

# 语句

## 程序的执行顺序

```
顺序执行
分支执行==》分支语句
循环执行==》循环语句
```

## 分支语句

```
一、if语句
	1.单分支
	2.双分支
	3.多分支
		3.1 if(条件){}
		3.2 else if(){}
		3.3 else{}
二、switch语句
	1.写法
		switch(变量){
			case 值1 ：
		满足值1执行的代码
		break；
		case 值2：
		满足值2执行的代码
		break；
		default：
		条件都不满足执行的代码
		}
	2.注意事项：
		2.1	判断时利用全等符号
```

## 循环语句

```
	1.while
		1.1	变量初始化；
		1.2	while(条件){满足条件执行的代码；变量更新}
	2.do...while
		2.1	变量初始化
		2.2	do{满足条件执行的代码；变量更新}while(条件)
		2.3	不管三七二十一，先做一遍
	3.for	==》for(变量初始化；条件；变量更新){满足条件执行的代码}
	4.	嵌套循环 ==》每次内层循环执行完毕一轮，外层循环才更新一次值
	5.	退出循环语句的关键字	
		5.1	break 	==》退出当前的整个循环	
		5.2	continue	==》跳过本次循环，执行下一次循环
		5.3	默认跳出一层循环
		5.4	利用标识符，跳出指定循环
```

# 函数

## 基本使用

概念

```
1. 将指定功能的代码封装到一个函数内
2. 好处
	2.1 可以重复调用
	2.2 便于维护
	2.3 简单易读
```

声明

```
1. 关键字声明
	1.1 function 函数名(形参){函数执行时的代码}
	1.2 可以提前执行
2. 赋值式声明 	
	2.1 var 函数名 = function(形参){}
	2.2 提前执行会报错，** is not a function
3. new Function();
```

声明提前

```
将所有的声明提升到当前作用域的最顶端，再按照代码执行顺序执行。
```

执行

```
1.手动执行
	1.1 函数名（）==》window.函数名()
	1.2 this一般都是window
2.事件驱动
	2.1 [onclick = "函数名()"]
	2.2 ele.onclick = 函数名;
	2.3 ele.onclick = function(){}
	2.4 this指的是事件绑定的元素，即ele
3.分类
	3.1 内置函数
	3.2 自定义函数
	3.3 匿名函数
```

## 作用域

```
1. 全局作用域==》全局变量==》在函数最外层声明的变量
2. 局部作用域==》局部变量==》在函数内部声明的变量
3.变量的访问规则
	3.1 若想在某个函数内使用某个变量，先在自己内部查找是否已声明。若找到则使用，若没找到，则往外一层函数寻找
	3.2 直到找到全局作用域，若存在则使用，若不存在则报错，**　is not defined
	3.3 作用域链：变量查找的路径	
```

## 参数

```
1. 形参==》函数声明时使用的参数，本质上是一个变量，相当于在函数内声明变量
2. 实参==》函数执行时使用的参数，本质上是一个值
3. arguments
	3.1 类数组，保存了所有实参的信息
	3.2 获取某个实参 arguments[索引]，索引从0开始
	3.3 arguments.length    
```

## 返回值 return

```
1. 作用：退出函数，函数内return后面的代码不再执行
2. 将函数内部的某个值返回给函数外部，函数外部要使用它，则必须接收一下。
3. 若return没有写，或者直接写了return，代表返回值为undefined
```

## 递归

自己调用自己，直到满足某个条件退出函数。

## 回调函数

将函数作为实参传递给另外一个函数，在另一个函数内执行

# 数组

## 定义

字面量==》 	var arr = [1,2,3]

构造函数==》	var arr = new Array()
​				var arr = new Array(10) 创建长度为10的数组
​				var arr = new Array(1,2,3) 

## 数组基本操作

1.arr[索引]
​	1.1 索引从0开始到arr.length-1
​	1.2 操作数组的具体某个索引对应的元素

2.arr.length

## 数组的方法

1. 增删改，会改变原数组

   ```
   1。数组增加元素方法
   	push(item)	==》往尾部增加一个或多个元素
   	unshift(item) ==》往开头增加一个或多个元素
   	返回值：返回数组增加元素后的长度
   2。数组删除元素方法
   	pop()	==》删除最后一位
   	shift()	==》删除第一位
   	返回值：被删除的那个元素
   3.splice(startIdx,delNum,item)
   	startIdx==》开始的位置，如果第一个开始，startIdx为1
   	delNum ==》 要删除的个数
   	item ==》元素，可写多个，用逗号隔开
   	
   	删：splice(startIdx,delNum)
   	增加： splice(startIdx,0,item)
   	修改： splice(startIdx,1,item)
   	返回值：被删除的元素组成的数组
   	
   	操作的都是startIdx的下一位的位置
   ```

2. 对原数组进行倒序排列reverse()，会改变原数组

   返回倒序后的新数组

3. 数组的排序sort(),会改变原数组

   sort(function(a,b){return a-b;}) //从小到大排序

   sort(function(a,b){return b-a;}) //从大到小排序

4. 对数组的裁切 slice()

   ```
   1.原数组不变，返回值为被裁切的新数组
   2.slice(start[,end])
   	2.1 从start索引开始截取，不包含end
   	2.2 end不写，代表截取到最后一个元素
   	2.3 可以取负值
   ```

5. 数组转成字符串  join(分隔符)

   分隔符若是省略，默认使用，将元素分隔开，返回值为拼接后的字符串

6. 数组的合并 concat(数组)

   返回合并后的新数组

## es5新增数组方法

1。遍历方法

```
1.forEach(function(item){}) //相当于for循环
2.map(function(item,idx,arr){return;})   //对数组中的每一项进行操作，最终返回一个新数组，长度等于原数组长度
3.filter(function(item,idx,arr){return 条件}) //过滤满足条件的每一项的元素，返回新数组
4.some(function(item,idx,arr){return 条件})   若存在一个满足条件的元素，则返回true
5.every(function(item,idx,arr){return 条件}) //只要存在一个不满足条件的元素，就返回false
```

2.归并方法	

reduce(function(prev,item,idx,arr){},initval)
​	prev代表函数上一次的返回值。
​	第一次为initval,若没定义为数组中的第一项

3.静态方法

​	Array.isArray()	==》判断是否为数组

4。索引方法

​	indexOf(keyword[,startIdx])
​		keyword是关键字，startIdx是开始查找的索引
​		若数组存在该元素，返回索引，如果不存在，返回-1	

## 数组排序

冒泡排序

```
当前元素跟下一个元素对比
把最大的逐个往后排列
外层循环i表示轮数
内层循环j表示当前索引，与j+1进行值的比较及换位
var arr = [12,3,44,343,55,1,23];
 for(var i = 1;i<= arr.length-1;i++){
      for(var j = 0;j < arr.length-1;j++){
          if(arr[j] > arr[j+1]){	//判断当前是否比后一位大
              var cur = arr[j];		//存起当前元素
              arr[j] = arr[j+1];	//前=后元素
              arr[j+1] = cur;		//后=之前存起的元素
          }
      }
 }
```

选择排序

```
把当前元素分别跟后面的元素对比
把最小的逐个往前排列
外层循环i表示当前索引
内层循环j表示与当前索引比较的索引值
 var arr = [12,3,44,343,55,1,23];
        for(var i=0;i<arr.length-1;i++){
            for(var j = i+1;j<arr.length;j++){
                if(arr[i] > arr[j]){
                    var cur = arr[i];
                    arr[i] = arr[j];
                    arr[j] = cur;
                }
            }
        }
```

快速排序

```
利用递归实现
 var arr = [10, 8, 20, 5, 6, 30, 11,9];
        function fastsort(arr){
            // 当数组的长度小于等于1，就没有中间值，就没法比较，可以直接返回
            if(arr.length <= 1){
                return arr;
            }
            // 1.找出中间索引
            var centerIdx = parseInt(arr.length/2);
            // 2.splice() 删除数组中的某个值，返回被删除的元素组成的数组
            var centerItem = arr.splice(centerIdx,1)[0];
            // 3.定义dayuarr、xiaoyuarr，大于中间数就放在dayuarr里面，小于等于中间数就放在xiaoyuarr里面
            var dayuarr = [];
            var xiaoyuarr = [];
            for(var i=0;i<arr.length;i++){
                if(arr[i]>centerItem){
                    dayuarr.push(arr[i]);
                }else if(arr[i]<=centerItem){
                    xiaoyuarr.push(arr[i]);
                }
            }
            return fastsort(xiaoyuarr).concat([centerItem],fastsort(dayuarr));
        }
        var newArr = fastsort(arr);
```

# 字符串

## 字符串定义

字面量 var str = “”

构造函数 var str = new String()

## 字符串操作

1.索引
​	1.1str[索引]    =>es5
​	1.2str.charAt(索引) 

2.长度
​	str.length

## 字符串的方法

```
1。不会改变原字符串

2。indexOf(keyword,startIdx)
	判断某个关键字是否存在字符串中，不存在返回-1
	
3。split(切割符)
	将字符串转成数组
	
4。replace(被替换的字符||正则，替换上去的内容)

5。裁切方法
	slice(start[,end])	==》可以取负数
	substr(start[,len])	==》len代表裁切的长度
		
6。大小写
	toLowerCase()
	toUpperCase()
	
7。转换字符编码
	charCodeAt(索引)	==》将字符串索引所在的字符转成字符编码
	String.fromCharCode(字符编码);	==》将字符编码转成字符
		
8. 裁剪前后空格 trim() 
```

# Math

Math.PI   ==》π

方法：

```
	Math.round() //四舍五入取整
		Math.round(3.5)	==》4
		Math.round(-3.5) ==》-3
		
	Math.ceil() 向上取整
		Math.ceil(3.1)==>4
		Math.ceil(-3.1)==>-3
	Math.floor() 向下取整
	
	Math.random()//返回0-1之间的随机数（不包括1）
	
	Math.abs()//绝对值
	
	Math.pow(a,b) // a的b次方
	
	Math.sqrt(num)   //num的开平方根
	
	Math.max()	//最大值
	
	Math.min()	//最小值
	
	三角函数
		Math.sin()
		Math.cos()
	 弧度=角度*Math.PI*deg/180
	 
	 例子：钟表每个小时的位置
	 c为半径
	 a为x轴距圆心的距离
	 b为y轴距圆心的距离
	 a=c*Math.sin(弧度)
	 b=c*Math.cos(弧度)
	 最终小时刻针坐标（半径+a,半径-b）
```

# Date

创建时间对象 

```
var d = new Date()
	1.无参数：本地时间的时间对象
	2.有参数
		2.1字符串 "2018/01/01 12:00:00"
			返回特定时间的时间对象
		2.2数字 距离1970年1月1日的毫秒数
			返回特定时间的时间对象
```

时间对象的方法	

```
获取方法：
getFullYear() 获取年份
getMonth() 获取月份，得到0-11
getDate()  获取日
getDay() 获取星期几,得到0-6，代表星期天到星期六
getHours() 获取时
getMinutes() 获取分
getSeconds() 获取秒
getTime()：获取某个日期自1970年1月1日0时以来的毫秒数

设置方法：
setFullYear() 设置年份
setMonth() 设置月份,0-11代表1到12月
setDate() 设置日
setHours() 设置时
setMinutes() 设置分
setSeconds() 设置秒
setTime()：修改某个日期自1970年1月1日0时以来的毫秒数
```

es5静态方法获取距离1970年的毫秒数

​	Date.parse("字符串“)   //”2017-01-01 12:00:00"

​	Date.now() //返回执行这行代码时距1970-1-1零时的毫秒数

定时器与延时器

```
setInterval(fn,time)  //每隔time毫秒执行一次函数fn
setTimeout(fn,time) //延迟time毫秒执行函数，只执行一次
清除定时器
	clearInterval(变量名)
	clearTimeout(变量名)
	
在函数里写定时器，清除定时器时注意指向
```

# BOM

## 概念

```
js三大组成= ECMAScript(ECMA)+BOM+DOM(W3C)
browser浏览器对象模型，操作的是浏览器窗口
window是最顶端的对象
```

## window

```
概念:
	1.若函数内没有通过var声明的变量，会被当做全局变量
	2.全局变量为window的属性
		2.1window. 调用可以省略
		2.2window本身存在的属性及事件不要省略
			2.2.1window.innerWidth
			2.2.2window.onload
		2.3尽量不要对window本身存在的属性进行赋值
	3.尽量不要定义全局变量
		3.1造成变量污染
		3.2命名冲突
属性及方法:
	1.页面的宽高
		window.innerWidth/innerHeight 浏览器可视区域的宽/高
		window.outerWidth/outerHeight  浏览器屏幕宽/高
			
	2.与滚动相关
		浏览器窗口滚动条滚动过的距离
			window.scrollX ===>水平滚动
			window.scrollY ===>垂直滚动
				
		设置滚动位置
			window.scrollTo(x,y) 
			window.scrollBy(x,y) 相对于你当前的滚动位置所在的位置
	3.window的事件
		window.onload  等待页面加载完毕后触发
		window.onscroll 浏览器滚动条滚动时触发函数        
		window.onresize 屏幕尺寸改变时触发
	4.系统弹窗   
		(1)alert() 弹窗
		(2) prompt(msg,默认值)   输入框，返回值为消息或者是null
		(3) confirm(msg)  确认框，返回值为布尔值
		以上三个方法都会暂停代码的执行 
		(4) open(url)  打开一个新窗口并返回新 window 对象
		(5) close() 关闭本窗口
		(6) print(): 调出打印对话框
		
```

## 属性对象

```
history(重要): 历史对象,包含窗口的浏览历史，可以实现后退 
	属性： 
		length 返回浏览器历史列表中的 URL 数量。

	方法： 
		back() 加载 history 列表中的前一个 URL。
		forward() 加载 history 列表中的下一个 URL。
		go() 加载 history 列表中的某个具体页面，支持负数。
	使用方法：
			history.go(2);//向前两个页面
			history.go(-2);//后退两个页面
 location(重要):  ocation是BOM最有用的对象之一，保存着当前窗口中加载文档的相关信息，还提供一些导航功能，它是个很特别的对象，既是window的属性，也是document的属性 
 	属性： 
	hash 设置或返回从井号 (#) 开始的 URL（锚）==>哈希值。
	href 设置或返回完整的 URL。
	search 设置或返回从问号 (?) 开始的 URL（查询部分）。
	如果传中文要转码和解码：
						encodeURI();//转码
						decodeURI();//解码
						
PS：修改以上属性(hash除外)都会刷新当前页面，并生成历史纪录 

方法： reload() 重新加载当前文档，带参数true表示不使用缓存刷新页面。

navigator（了解）:  导航对象, 包含所有有关访问者浏览器的信息，通常用于检测浏览器类型 

- appName 浏览器名称
- appVersion 浏览器版本
- platform 操作系统
- userAgent 用户代理信息，通过该属性可以获取浏览器及操作系统信息
- geolocation 获取地理位置信息

```



# DOM

document object model 文档对象模型，w3c

## 获取节点

```
1.获取元素节点
	document.getElementById() 返回得到元素对象或者null
	getElementsByClassName  返回得到类数组或者[] ===>	通过任意节点调用
	getElementsByTagName  返回得到类数组或者[] ===>	通过任意节点调用
	document.getElementsByName  返回得到类数组或者[]
2.利用节点关系，获取到其他节点（文本、元素节点）
  	一、获取父级节点
//ele.parentNode 得到节点的父节点
  ele.parentElement 得到节点的父元素节点 
  
	二、获取子节点
  1.获取元素的全部子节点列表
//ele.childNodes 得到ele元素的全部子节点列表（类数组）
  ele.children 得到ele元素的全部子元素节点列表（类数组）
  
  2. 获得ele元素的第一个子节点
//ele.firstChild 获得ele元素的第一个子节点 （包括文本节点）  
  ele.firstElementChild 获得ele元素的第一个子节点（不包括文本节点） 
  
  3。获得ele元素的最后一个子节点
 // ele.lastChild 获得ele元素的最后一个子节点  （包括文本节点）
  	ele.lastElementChild 获得ele元素的最后一个子节点（不包括文本节点） 
  	
	三、获取兄弟节点
	1.下一个兄弟节点
// ele.nextSibling 获得节点的下一个兄弟节点  （包括文本节点）
	ele.nextElementSibling 获得节点的下一个兄弟节点  （不包括文本节点） 
	2.上一个兄弟节点（
// ele.previousSibling 得到节点的上一个兄弟节点（包括文本节点）
	ele.previousElementSibling 得到节点的上一个兄弟节点（不包括文本节点） 
		
```

## 三大节点的三大属性 

```
元素节点
	nodeType 1
	nodeName 标签名大写
	nodeValue   null
属性节点
	nodeType 2
	nodeName 属性名
	nodeValue  属性值
文本节点
	nodeType 3
	nodeName  #text
	nodeValue   文本内容
```

## 节点的增删改查

```
father 为父元素节点
创建节点
	document.createElement("标签名")
插入节点
	father.appendChild(ele)    往父元素节点添加最后一个子元素
	father.insertBefore(new,old) 在old节点之前插入new节点
删除节点
	father.removeChild(ele)
复制节点
	ele.cloneNode(true) 
		返回值为复制后的新节点
```

## 节点属性与html元素属性的区别

```
1.节点是对象，通过.或者[]对节点的属性进行操作

2.html元素是页面结构，html属性="属性值" 写在标签里面

3.标准属性会互相影响
```

## 节点的属性及方法

```
1.节点的属性
	tagName
	className
	name
	id
	style
	innerHTML
	innerText
		只操作文本
2.节点的方法
	setAttribute(”html属性“,”属性值“) ===>设置html属性

	getAttribute("html属性") ===> 获取html属性的属性值
		
	removeAttribute("html属性") ===> 移除html属性
		
	hasAttribute("html属性”) ===> 判断是否存在某个html属性
		
3.盒模型相关的属性
	ele.offsetWidth
	offsetHeight
		元素的宽高（content+padding+border）
	offsetLeft
	offsetTop
		到最近的定位父级的距离
		若无定位父级，则到html的距离
4.获取css样式
	内联样式
		ele.style
	标准浏览器
		window.getComputedStyle("ele") 得到包含所有css样式的对象
			window.getComputedStyle("ele") .width
	ie浏览器
		ele.currentStyle  得到包含所有css样式的对象
	
```



# Event事件

## 事件绑定方式

1. html属性 [onclick="函数名(实参)"]  

   不推荐使用，维护不方便，调用数据困难

2. "on"+type :

* ele.onclick = 函数名;

* ele.onclick = function(){}

* 只能在冒泡阶段执行,只能给同一个元素绑定一个相同事件

3. 事件监听器

* ele.addEventListener(type,fn,isCapture)  ==>标准浏览器
  * type 事件类型
  * fn 函数
  * isCapture 是否捕获，若为true为捕获阶段，默认为false冒泡阶段

* 允许给同一个元素添加多个相同事件

* ele.attachEvent("on"+type,fn) ==>ie8-不支持捕获

### 常用事件

#### 鼠标事件

on**click** 点击。
on**dblclick** 双击。
onmouse**down** 鼠标按下。
onmouse**up** 鼠标松开。
onmouse**over** 鼠标移入。
onmouse**out** 鼠标移出。
onmouse**move** 鼠标移动。
onmouse**enter** 在鼠标移入。这个事件不冒泡
onmouse**leave** 鼠标移出。这个事件不冒泡
on**contextmenu** 鼠标右键菜单展开时触发。
PS：click = mousedown + mouseup, dblclick = click*2(短时间内两次单击);
执行顺序：mouseover=>mouseenter; mouseout => mouseleave

#### 键盘事件

onkey**down** 某个键盘按键被**按下**。
onkey**up** 某个键盘按键被**松开**。
onkey**press** 键盘**<字符键>**被**按下**触发,**按住不放重复触发**

#### UI事件

on**load** 页面元素（包括图片多媒体等）加载完成后
on**scroll** 滚动时触发。
on**resize** 窗口或框架被重新调整大小。

#### 表单事件

on**select** 输入框文本被选中。
on**blur** 元素**失去焦点**时触发。
on**focus** 元素**获得焦点**时触发。
on**change** 元素**内容被改变**，且**失去焦点**时触发。
on**reset** 重置按钮被点击。
on**submit** 确认按钮被点击。
on**input** 输入字符时触发

## Event对象

### event对象作用

​	保存事件执行过程中的信息

ie浏览器window.event

兼容ie浏览器 e = e||window.event

# cookie

## 基本设置及获取

### 1.设置（存储）:

​    	document.cookie = "cname=cval"

​	每次只能设置一条cookie

### 2.获取：document.cookie

​	一次性获取到所有的cookie,是一串字符串

## cookie的组成

### 1.设置（存储）:

document.cookie = "cname=cval[; expires=日期对象的字符串]"

每个参数后加空格

​	expires 设置期限
​		 默认情况下，为临时存储
 		**d.toUTCString()** 具体日期

​	path 设置cookie的存储路径
 		默认路径为当前文件所在的文件夹
 		/ 根目录

```
设置cookie 保存7天期限+ cookie储存地址
var d = new Date();
d.setDate(d.getDate()+7)
document.cookie = 'name=value; expires = '+d.toUTCString()+'; path=/';
```



### 2.获取：document.cookie

​	 从当前文件夹往上找到根目录的所有cookie

​	如果要找到子文件夹下的cookie，则子文件夹cookie的储存地址改为根目录，即;path=/;

​	字符转数组  document.cookie.split('; ')  分号空格 裁剪字符串

​	

## JSON

```
-JSON字符串
	-'{“name":"lemon","age":17}'
	-'[{"name":"lemon"},{"name":"laotian"}]'
- 转换
  - 对象/数组 -> json字符串：JSON.stringify() :得到标准格式的JSON
  - json字符串 -> 对象/数组：JSON.parse()
- 格式：
  - 属性名和字符串必须使用双引号
  - 不能有注释
  - 不能存在多余逗号
- 属性值必须为以下类型
  - String
  - Number
  - Boolean
  - Object
  - Array
  - Null
  
空字符串不能通过JSON.parse()转成对象，会报错：Unexpected end of JSON input（该内容不是json字符串）
```

# 正则表达式

## 创建正则的两种方式

```
-var reg = /正则/gi
-var reg = new RegExp("正则","gi")
	-var reg = new RegExp(变量,"gi")
	-构造函数的方式声明正则,正则使用了\的前面再加\
```

## 正则的匹配规则

字符类

```
. 匹配换行外的任意字符
\d 数字0-9           \D 非数字
\w 包含字母、数字、下划线
\s 空格
\b 匹配数字或单词边界（空格、汉字）
```

特殊符号

```
1	[] 或者,表示满足中括号内其中一个条件即可
		- 表示区间
		 ^ 表示非
2	{} 表示数量,默认贪婪模式(会尽可能多的去匹配结果)
		var str = "aaaaaaaaaaaaaaaaaabbbb";
			str.match(/a{1,}/g)
				"aaaaaaaaaaaaaaaaaaaa"
			非贪婪模式
				str.match(/a{1,}?/g)
					"a"
		 {a} 表示匹配a个
		  {a,} 表示匹配a个及以上
		 {a,b} 表示匹配a到b个
3	+ : {1,}
4	* : {0,}
5	? : {0,1}
6	锚点定位
		^ 表示以什么开头
		$ 表示以什么结尾
7	| 或者
8	若特殊符号需要当做普通字符使用，用\转义
		\+ 此时+为普通字符
```

## 创建正则表达式

```
第一个参数“字符串”
var reg= new RegExp('study');
//使用特殊字符
var reg= new RegExp('\\d\\w+');\d\w+
第二个参数可选，模式修饰符
var reg = new RegExp('study', 'ig');
```

# ES5

ie9及以上浏览器支持

## 页面执行顺序

```
工作中script写在body最后面
1. 解析HTML结构。
2. 加载外部脚本和样式表文件。
3. 解析并执行脚本代码。
4. DOM树构建完成。//DOMContentLoaded
5. 加载图片等外部文件。
6. 页面加载完毕。//window.onload


1.dom树构建完毕
	1.1 document.onreadystatechange 准备阶段改变时触发
		1.1.1 interactive 等待dom树构建完毕
		1.1.2 complete 页面加载完毕
	1.2 document.addEventListener("DOMContentLoaded",function(){})
```

## 获取元素

```
document.querySelector(css选择器) 获取到第一个满足条件的节点
document.querySelectorAll(css选择器)   得到包含所有满足条件的元素组成的类数组
```

## function的方法

```
bind(obj)
	改变函数内部的this指向obj，返回新的函数
```

## classList 保存所有类名的类数组

```
classList:js 的方法 （他是一个对象）
ele.classList.add() ==>添加class方法   在原有的基础上加class，可加多个，用逗号分隔
ele.classList.remove() ==>删除class方法
ele.classList.toggle() ==>切换class方法   存在class就删除   不存在就增加。
ele.classList.contains() ==>是否含有某个类,返回布尔值
ele.classList.length 类名的长度
```

## dataset 保存所有标准自定义属性的对象

```
1.符合W3C标准自定义属性：data-*
2。可以增删改查属性
	获取 ele.dataset.**
		[data-name = "lemon"]
	设置 ele.dataset.age=17 
		[data-age="17"]
	删   		delete ele.dataset.age;

data-name :  dataset.name
多个横杠，名字变为驼峰命名
data-name-first  :  dataset.nameFirst
```



## ES5的严格模式

```
为什么要用严格模式
- 消除javascript语法的一些不合理，不严谨的地方，减少一些怪异行为；
- 消除代码运行的一些不安全之处，保证代码运行的安全；
- 提高编译器效率，增加运行速度；
- 为未来新版本的javascript做好铺垫；

使用方法：“use strict”;
	全局：写在js文件的第一句
	局部：写在函数内的第一句
```

### 执行限制

```
- 不使用var声明变量严格模式中将不通过
- 删除系统内置的属性会报错
- delete不可删除属性的对象时报错，如：
  	- var声明的全局变量（会自动称为window的属性）
- 对象有重名的属性将报错
	var obj={name:"小王",name:'王大锤'}
- 函数有重名的参数将报错
	function sum(a,a,b){}
- arguments严格定义为参数
 	 - 不允许对arguments赋值
 	 - 禁止使用arguments.callee
- 函数必须声明在顶层，不能写在条件判断语句或for循环语句中
	var arr = [10,2,3,50];
	if(arr.length>3){
	    function sum(){//报错
	
	    }
	}
```



# ES6

## 变量声明

- let: 代码块内的变量声明

  1. 变量声明不会提前
  2. 块级作用域
  3. let不允许相同作用域内多次声明同一变量

- const:常量声明

  1. 变量声明不会提前

  2. 块级作用域

  3. const不允许相同作用域内多次声明同一变量

  4. 声明后无法修改值

  5. 不成文规定 起名全用大写，多单词用-隔开

     > const常用与引用第三方库的声明

## 解构赋值

概念：从数组或对象中提取值，对变量进行赋值，这种防止叫做解构.

1.数组

```
1.[变量名，变量名,....]=数组；
例如:var [a,b,c]=[10,20,30];
2.	...表示获取剩余参数；
例如：var [a,...b]=[10,20,30] 返回 a=10; b=[20,30]；
3.解构失败
（1）变量的长度大于数组的长度，出现解构失败，得到undefined   例如：var [a,b]=[10,20];  c报undefined
（2）解构右侧不是数组，报错    例如：var [a]= 10;
4.默认值：当a解构失败的话，拿到默认值；
例如：
var arr = [10,20];
var [a=0,b=0,c=0] = arr;   
返回a=10 b=20 c=0
```

2.对象解构 （等于拿值 对本身不影响）

```
1.基本解构{变量名，变量名}=对象
	要求变量名域对象的属性一致
	var obj={name:"laotian",age:38,gender:'nan'}
	var {name,age,gender}=obj
2.解构失败：变量名域属性名不一致，会出现解构失败
var {name,sex,gender}=obj 会解构失败 会报is not defined
3.如果变量名和属性名不想用，则必须写成以下格式下才能去取到值：{属性名:变量名}
var {name,age,gender:sex}=obj
4.指定默认值：当变量解构失败的话，拿到默认值
5.不仅解构时可以传递默认值，基本数据类型作为形参时也可以传递默认值，也可以通过...变量名获取剩余的参数
```

3.解构同样适用于let和const

PS:解构只能用于数组和对象，如果解构不成功，变量会返回undefined，但如果对undefined和null解构则会报错

## 解构用途

交换变量值

函数返回多个值

```
function example(){
     return [1,2,3]
}
//接收
var [x,y,z] = example();
```

定义函数形参（重点） 函数的参数定义方式, 不用再考虑参数的顺序

```
function test({x,y,z}){}
//传参
test({x:10,y:20,z:30})
//参数可以设置默认值
fuction test({x=10,y=20,z}){}
```

## 字符串扩展

### 字符串的方法

1. includes 判断是否包含某个字符，返回布尔值，类似indexof
2. startsWith/endsWith 是否以某一字符开头/结尾
3. repeat(n) 得到字符串重复n次后的结果，n可以为小数，但不能为负数

### 字符串模板template string (重点)

使用反引号`表示，在字符串中插入变量 格式：${变量|函数}，

```
 `你好，我的名字叫${username},接下来是我的自我介绍：${introduce()}` 
```

模板字符串中所有的空格、新行、缩进，都会原样输出在生成的字符串中。

## 遍历扩展

### 遍历

- for..of

  ```
  var arr = [10,12,18,30]
  for (var value of arr) {
    console.log(value);
  }
  ```



- 这是最简洁、最直接的遍历数组元素的语法

- 这个方法避开了for-in循环的所有缺陷

  > for…of跟for-in的区别很明显，就是直接取值，而不再取下标了

- 与forEach()不同的是，它可以正确响应break、continue和return语句

- for-of循环不支持普通对象

- for-of循环也可以遍历其它的集合

  - DOM节点集合(HTMLCollection/NodeList)
  - 字符串
  - 数组
  - Set集合/Map映射
  - …

## 函数扩展

### 箭头函数（重要）

格式：标识符=>表达式
省略了function、return关键字、圆括号、花括号

1.函数内只**有一句return代码**：省略了functoin、return、{}
​        //  （1）没有参数或存在多个参数

```
var sum = () => 10+10;单个参数
var sum = (a,b) => a+b;多个参数
```

​        //   	(1) 只有一个参数，还可以省略()

```
var test = x=>x+2;
```

 2.函数内有**多句代码**，**不要省略{}、return**
​        // * 箭头函数=>后面紧跟着的{}代表的是代码块

​	//使用了**块语句**的箭头函数**不会自动返回值**，你需要使用**return**语句将所需值返回

```
var sum = (a,b) => {
            console.log(this);
            var c = a * b +1;
            return c+1;
        }
```

3.当使用箭头函数返回一个普通对象时，需要将对象包裹在小括号里

```
var createPerson = ()=>({name:'laoxie',age:18});
//不给对象写（）会报错。
```

4.默认参数Default

```
var func1 = (x = 1, y = 2) => x + y;
func1(); // 得到 3
```

5.剩余参数Rest

```
var func2 = (x, ...args) => console.log(args);
func2(1,2,3); // 输出 [2, 3]
```

6.箭头函数自身没有this，箭头函数内的this值继承自外围作用域，即继承上一作用域。

## 对象的扩展（重要）

### 对象的合并

Object.assign(obj1,obj2) 将多个对象合并成obj1,并返回obj1

### 对象的传递与复制

1. var obj2 = obj1;传递是地址，所以一旦改变其中一个对象的值，另外一个会受影响

2. 浅复制（对于引用类型，只拷贝地址）

   ​	（1）for...in 遍历对象中的键，传递给另外个对象

   ```
   var obj3 = {};
    for(var key in obj1){
        obj3[key] = obj1[key];
    }
   ```

   ​	（2）var new = Object.assign({},obj);

3. 深复制：var new = JSON.parse(JSON.stringify(obj1))

   ​	将引用数据类型转成基本数据类型进行传递

   ​	再转成引用数据类型

### 对象简写

1.属性直接写变量名：变量名作为属性名，变量值作为属性值。

2.属性为[变量名],代表变量值为属性名

3.方法简写:方法名(){}

```
var fruit = "lemon";
var obj = {
	fruit,// 等同于：fruit : "lemon"
	[fruit] : 2, // 等同于： lemon : 2
	show(){}//  等同于：show : function(){}
}
```

### Map映射（键值对）

    （四）map集合:它能让所有类型的数据作为键
    常用方法：
     - 设置set(key, value)
     - 获取get(key)
     - has(key)
     - delete(key)
     - clear()
    遍历方法：
      - keys() 获取所有键(类数组)，可以用Array.from()转成数组
      - values() 获取所有值，可以用Array.from()转成数组
      - entries() 获取所有键值对，可以用Array.from()转成数组
      - for(var item of map){item存放map集合的每一项键值对，item为一个数组，item[0]代表键，item[1]代表值}
          * 配合解构：获取for(var [key,val] of m){key代表map集合的每个键，val代表每个值}
## 生成器函数 Generators

格式：function* gen(){}

函数体内部使用了yield 表达式  代表暂停代码的执行

next()

- 执行next()后得到一个yield或return返回值组成的**对象**`{value:xx,done:false}`
- 对象中的done是否为true,取决于函数是否完结束 

## Symbol数据类型

symbol 表示**独一无二**的值，一旦**创建后就不可更改**

接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了标识和区分

symbol**不可以**与**其他类型**的值进行**运算**，会报错

Symbol.for() 第一次就是创建symbol,会先查找当前Symbol是否存在

#### 用途

解决，创建私有属性或现有添加属性，可能会重名冲突的问题

```
var mySymbol = Symbol();

// 第一种写法
var a = {};
a[mySymbol] = 'Nani';

// 第二种写法（注意加方括号，否则回被当作普通属性）
var a = {
  [mySymbol]: 'Nani'
};

// 以上写法都得到同样结果
a[mySymbol] // "Nani"
```

## Set集合

 var s = new Set();

### 方法

类似于数组，但是成员的值都是唯一的，可自动去重。

去重的前提是两个值**恒等于**。

数组、 对象因为他的地址不一样，只是同名，所以不会去重

 利用set集合去重数组

**Array.from(set集合)** 将set集合或者**类数组转成数组**

（1）set的方法：

​	add(value)：添加某个值，**返回Set结构本身**。

​	delete(value)：删除某个值，**返回一个布尔值**，表示删除是否成功。
​	has(value)：**返回一个布尔值**，表示Set集合中是否存在该值。

​	clear()：清除所有成员，**没有返回值**。
（2）遍历set集合
​	 forEach()
​	for(var item of s){item代表集合中的每一项值}

# 动画

利用定时器，改变对象的属性，从而改变样式，产生动画的效果

## 匀速运动

```
1.初始化速度变量
2.开启定时器
	(1)获取当前值
	(2)改变当前值：当前值+速度
	(3)将改变后的值赋值给元素的样式
	(4)当改变后的值大于等于目标值，清除定时器，同时将改变后的值改成目标值。这一步应该在赋值给样式之前
```

## 加速运动

```
多了速度不断增加条件
1.初始化速度变量
2.开启定时器
	2.1获取当前值
	2.2改变当前值：当前值+速度
	2.3速度不断增加
	2.5当改变后的值大于等于目标值，清除定时器，同时将改变后的值改成目标值。这一步应该在赋值给样式之前
	2.4将改变后的值赋值给元素的样式

```

## 减速运动

```
多了速度不断减少条件
1.初始化速度变量
2.开启定时器
	2.1获取当前值
	2.2改变当前值：当前值+速度
	2.3速度不断减少
	2.5当速度小于0时，清除定时器。写在速度自减下面
	2.6当改变后的值大于等于目标值，清除定时器，同时将改变后的值改成目标值。这一步应该在赋值给样式之前
	2.4将改变后的值赋值给元素的样式
```

定时器在事件里 清除上一次定时器 可以给timer 创建全局变量  或者 写成obj.timer 或者定时器用箭头函数，直接this定时器名 

## 抛物线

```
初始化速度变量、获取、改变当前值都要(水平、垂直)，垂直方向速度减小
1.初始化速度变量（水平、垂直）
2.开启定时器
	(1)获取当前值(水平、垂直)
	(2)改变当前值：当前值+速度(水平、垂直)
	(3)速度不断减小（垂直方向的速度）
	(5)当改变后的值大于等于目标值，清除定时器，同时将改变后的值改成目标值。这一步应该在赋值给样式之前
	(4)将改变后的值赋值给元素的样式
```

## 圆周运动

```
 <script>
        document.addEventListener('DOMContentLoaded',()=>{
            // 页面布局完成：
            // 1.太阳定位在浏览器可视区域中间
            // 2.太阳半径130+25=155  地球半径15px.从而实现地球的定位
            // ==========================================
            let sun = document.querySelector('.sun');
            let earth = document.querySelector('.earth');
            //半径、初始化位置（居中）
            let sun_r = 155;//130+50/2//太阳半径加阴影距离
            let earth_r = 15;
            //太阳，地球居中
            sun.style.left = (window.innerWidth - sun.offsetWidth)/2 + 'px';
            sun.style.top = (window.innerHeight - sun.offsetHeight)/2 + 'px';
            earth.style.left = (window.innerWidth - earth.offsetWidth)/2 + 'px';
            earth.style.top = (window.innerHeight - earth.offsetHeight)/2 - sun_r + 'px';	
            //获取中心点位置
            var centerX = window.innerWidth/2;
            var centerY = window.innerHeight/2;
            //===做动画
            //1.初始化速度变量（角度）
            var deg = 0;
            var speed = 5;
           // 2.开启定时器
            setInterval(function(){
            	//改变当前值：当前值+速度
                deg += speed;
                //获取当前值
                var rad = toRad(deg);
                var pos = toPos(rad);
                //将改变后的值赋值给元素的样式
                earth.style.left = pos.earthX + 'px';
                earth.style.top = pos.earthY + 'px';
            }, 50)
			//封装获取弧度的坐标
            function toPos(rad){
            //用三角函数求出坐标
            var earthX = centerX + sun_r*Math.sin(rad) - earth_r;
            var earthY = centerY - sun_r*Math.cos(rad) - earth_r;
            //用对象组成坐标返回出去
                return {
                    earthX,
                    earthY
                };
            }
			//封装角度转弧度，角度除乘π除180
            function toRad(deg){
                return deg*Math.PI/180;
            }
        });
    </script>
```

## 缓冲动画

```
关键：动态计算速度（目标值-当前值有关） 
不用设定初始速度
1.开启定时器
	(1)获取当前值
	(2)获取当前速度(目标值-当前值).
	     * 当速度大于0时，Math.ceil()
	     * 当速度小于0时，Math.floor()
	(3)改变当前值：当前值+速度
	(4)将改变后的值赋值给元素的样式
	(4)当改变后的值等于目标值，清除定时器
	* 若事件里面开启定时器，记得开启定时器先清除定时器
	因为滚动条不会超出0，所以可以放在赋值后
```

# PHP

## php的基本语法

（1）基本结构 <?php ?>
 (2) 注释同js
 (3) 变量

    - 以 $ 符号开始，后面跟着变量的名称（$称为标识符，不属于变量组成部分）
        - 只能包含字母、数字字符以及下划线，不能以数字开头（不能包含空格）
        - 区分大小写
        - 没有声明变量的命令，也没有声明提前的概念。
    * 定义常量并赋值：define("MY_NAME", "laoxie"); 
    
       ```
       $fruit = "lemon";
       $Fruit = "apple";
       ```
    
       (4)作用域：
    - 全局变量：在函数外部定义的变量，可以在任意位置访问(需要手动定义为全局变量)
        - 局部变量：函数内部声明的变量，仅能在函数内部访问
    * 手动定义为全局变量:
        * global关键字: global $变量名
        * $GLOBALS 超级全局变量，数组： $GLOBALS["变量名"]
         (5) 输出语句
            echo 可以输出一个或多个字符串（字符串可以包含HTML标签），速度较快，一般用于向前端返回数据
            print_r()	打印关于变量的信息，适用于数组、对象的打印，一般用于测试
    		var_dump()	判断一个变量的类型与长度,并输出变量的数据类型和数值，一般用于测试
    	（6）拼接字符串    .  

## 数据类型

```
String（字符串）
Integer（整型）
Float（浮点型）
Boolean（布尔型）
Array（数组）
Object（对象）
NULL（空值）
```

### 字符串string

```
- strlen() 获取字符串长度，得到的字符的字节数
$name = "lemon";
echo strlen($name);

- mb_strlen() 获取字符串长度
echo mb_strlen($name);、

- strpos() 查找某个字符在字符串中的索引(字节数)，如果未找到匹配，则返回 false
echo strpos($name,"e");
```

### Array

（1）创建数组：array()

```
（1）数值数组 array(1,"aa",3)
（2）关联数组(类似于js对象) 
     * => 代替 :
  例子： $arr2 = array(
        "name" => "lemon",
        "age" => 17
        );
 (3) 多维数组:一般都是外层为数值数组，内层为关联数组（类似于js的数组对象）
例子：	 $goodslist = array(array(
	            "goodsName" => "电动牙刷",
	            "price" => 200
	        ),array(
	            "goodsName" => "牙线",
	            "price" =>10
	        ));
```

2.操作数组
​	数组[索引/'键']

3.常用方法：

```
1. count($name) 获取数组的长度    
2. array_rand($name) 随机获取数组的索引值
3. in_array(key,$name) 判断某个值是否存在数组中
4. array_slice($name,开始索引,len) 从数组中取出一段
$arr = array(1,"aa",3,"bb","cc","dd");
var_dump(array_slice($arr,2,2));//截取3，'bb'
```

4.遍历

```
1. for() 一般用于遍历数值数组
2. foreach() 一般用于遍历关联数组     
 2.1 foreach($arr as $item)   遍历数值数组,$item代表数组每一项
 2.2 foreach($arr2 as $key => $val) 遍历关联数组，$key代表数组每一项的键，$val代表数组每一项的值
```

5.数组排序

```
- sort() 对数组进行升序排列
- rsort() 对数组进行降序排列
- asort() 根据关联数组的值，对数组进行升序排列
- ksort() 根据关联数组的键，对数组进行升序排列
- arsort() 根据关联数组的值，对数组进行降序排列
- krsort() 根据关联数组的键，对数组进行降序排列
```

##  获取前端数据

```
$_GET["属性名“] 获取前端用get方式传递过来的数据（url地址后面数据也能被获取）
$_POST["属性名“]	获取前端用get方式传递过来的数据
isset() 判断某个值是否被设置，若不存在返回boolean
```

## 本地文件操作

```
$file=open($path,"模式")=》打开文件
	1- r 只读打开文件，从文件头开始读
	2- r+ 读写打开文件，追加的方式写入文件
	3- w 以写入方式打开文件，从文件头开始写。文件不存在则尝试创建，若存在，则先删除文件中的内容
	4- w+ 以读写方式打开文件，从文件头开始读写。文件不存在则尝试创建，若存在，则先删除文件中的内容
	5- a 以写入方式打开，从文件末尾开始追加写。如果文件不存在则尝试创建
	6- a+ 以读写方式打开，从文件末尾开始追加写入或者读。如果文件不存在则尝试创建。
$content = fread($file,长度)=》读取文件
	长度=》filesize($path)
	$path=>引入json文件的路径/接口
fwrite($file,$content)=》写入文件
fclose($file)=》关闭文件
```

echo返回数据

```
json_encode(array,JSON_UNESCAPED_UNICODE); 把数组转成字符串
	php5.4+ 使用JSON_UNESCAPED_UNICODE防止中文转义
json_decode(json,assoc); 把字符串转成数组/对象
	json：待解码的 json string 格式的字符串
	assoc：默认false,返回object, 当该参数为 true 时，将返回array
```

# ajax

关键点在于XMLHttpRequest异步请求对象

## ajax基本请求步骤

```
1.创建异步请求对象	var xhr = new XMLHttpRequest();
2.建立与服务器连接,设置请求参数 open(type,url,async)
      type 请求类型：
      	1.get=>得到   
      	2.post=>发送
      	3.区别：
      			1.get请求的数据通过url传递给服务器，post请求的数据保存在request body发送（send()）
				2.get发送的数据有长度限制，post没有限制
				3.get发送的数据暴露在url中，所以安全性比post请求低
				
      url 请求路径(get请求的数据必须接在url后面)
          1.相对路径：保证请求的路径跟当前路径在同一个根目录
          2.绝对路径：同源策略
              同域（同源策略）：协议，域名，端口三者一致
          3.get请求：路径?属性名=属性值&属性名=属性值
          4.报错： No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'null' is therefore not allowed access. 说明跨域了
          
      async 是否异步，默认为true（异步）
          异步：与其他操作同时执行，也叫并发（图片加载，ajax请求，定时器）
          同步：按步骤顺序执行，前面的代码执行完后，后面的代码才会执行（排队）
3.发送请求 xhr.send()
    post: send(data)表示发请求时传送的数据字符串，
    	请求的数据保存在request body发送
    	发送的数据长度没有限制
    get: send(null)
    	发送数据有限制
    	发送的数据暴露在url中,安全性比post低
4.等待响应数据解析完毕，处理服务器返回数据 
	xhr.onreadystatechange = function(){}
    判断准备阶段xhr.readyState == 4，
    判断http响应状态 xhr.status==200 || xhr.status==304
    接收响应数据 responseText   接收的都是字符串
   	
```

例子：

```
var xhr = new XMLHttpRequest();
var status = [200,304]
xhr.onreadystatechange= function(){
    if(xhr.readyState ==4&& status.indexOf(xhr.status)!=-1){
        var res = JSON.parse(xhr.responseText);//接收
    }
}
xhr.open('get','../data/goodslist.json',true)//相对路径
//xhr.open("get","http://localhost:1810/data/goodslist1.json",true);//绝对路径
 xhr.send(null)  //null不返回数据
```

## 跨域解决方案

### jsonp

```
1.利用script标签可以跨域访问其他文件，而不是用ajax请求。从而达到跨域请求数据的效果
2.前端需要做的事情
	(1).script[src="接口?cb=函数名”]
	(2).全局定义的函数 ==>window.函数名 = function(){}
3.局限性
	(1).后端必须要有回调函数的执行
	(2).只能用get请求		
```

### CORS  

全称是”跨域资源共享”

CORS需要浏览器和服务器同时支持。ie不低于ie10

```
写响应头，前端直接连接地址
1.Access-Control-Allow-Origin
	header('Access-Control-Allow-Origin: *');  
该字段是必须的。需要在后端响应头添加词字段，值要么是一个*，表示接受任意域名的请求，要么指定一个域名http://localhost。
2.Access-Control-Allow-Methods
3.Access-Control-Allow-Headers
    header('Access-Control-Allow-Methods:POST');  
    header('Access-Control-Allow-Headers:x-requested-with,content-type');
```

### 服务器代理

后端不存在跨域问题，所以可以利用后端间接获取其他网站的数据

```
ajax跨域请求之服务端代理（爬虫）
原理：获取页面所有内容，并利用正则匹配所需内容
获取其他网站的所有内容
	file_get_contents($url) 或$url 直接写"绝对地址"
利用正则匹配需要的内容
	例如：$reg = '/\[((?:\d+\.){3}\d+)\]/';
	preg_match_all($reg,$str,$res) 
	preg_match($reg,$str,$res)   
	// $res正则 $str代表被匹配的内容，$res为结果 他的值为数组[整个匹配的结果，分组匹配的结果]
	如果编码器不同，解决乱码问题
	$content = iconv(原字符编码,新字符编码,$content);//修改$content字符编码
```

## Promise

Promise是一个构造函数，用来传递异步操作的消息，类似回调函数

Promise 的三种状态

```
Pending（未完成）可以理解为Promise对象实例new创建时候的初始状态
Resolved（成功） 可以理解为成功的状态
Rejected（失败） 可以理解为失败的状态
var p = new Promise(function(resolve,reject){
      resolve()//执行第一个参数resolve()，相当于执行p.then()里面的函数
      reject() // 执行第二个参数reject(),相当于执行p.catch()里面的函数
 })
 p.then(function(data){
            console.log(data);
        });
 p.catch(function(res){
            console.log(res)
        });
```

静态方法

Promise.all([p1,p2,p3...])

```
- 将多个Promise实例，包装成一个新的Promise实例
- 所有参数中的promise状态都为resolved时，新的promise状态才为resolved
- 只要p1、p2、p3..之中有一个被rejected，新的promise的状态就变成rejected 
Promise.all([p1,p2,p3]).then(function(res){
	console.log(res);
})
```

Promise.race([p1,p2,p3...]) // 竞速，完成一个即可

## json

json字符串与对象的转换

```
//（一）json字符串转成对象的转换
//1. eval("("+json字符串+")"); 
它的作用是，将一个普通的json格式的字符串，转换成Json格式的对象

//var list = eval("("+request.responseText+")");

//2. JSON.parse(); //把JSON字符串转成JSON对象(js对象/数组)【es5】

//（二）把JSON对象转成JSON字符串
JSON.stringify(); 
```

补充：eval的使用

```
var json = '{"name":"lemon","age":18}'; //标准json字符串
var json = '{"name":"lemon",\'age\':18}';//不标准
eval('('+json+')');//也可以转成对象
eval('1+2');//3
eval('定义函数；执行函数') //函数可以在字符串中执行
```

微博点赞案例

```
php
<?php
1.接收前端发送的currentId.
  判断currentId有没有设置 isset()
      若有则接收currentId,若没有设置默认值1
2.对文件内容的读取出来==>用$content接收
  (1) 获取文件路径$path
  (2) 打开文件（读取）$file = fopen($path,打开文件模式)
  (3) 读取文件 fread($file,读多少)
      * filesize($path)：读取文件字符长度
  (4) 关闭文件 fclose($file)
3.json字符串转成数组
 json_decode(json,assoc);把字符串转成数组/对象
      json：待解码的 json string 格式的字符串
      assoc：默认false,返回object, 当该参数为 true 时，将返回array
4.对$content进行遍历，找到与currentId相等的那个对象，对其的likecnt进行++运算。
  * 数值数组for循环，直接操作数组
5.将$content重新写入文件
 （1）以只写方式打开
 （2）写入 fwrite(file,json字符串)
     *json_encode(array,JSON_UNESCAPED_UNICODE);  把数组转成字符串
     php5.4+ 使用JSON_UNESCAPED_UNICODE防止中文转义
6.将当前被改变的关联数组的点赞数返回给前端。
？>
```

# MYSQL

## 存储、管理有组织的数据

```JS
1.结构化
2.关系型数据库 ===> 多个表可以通过某个外键实现关联
```

## 操作

### 1.连接mysql

```js
//php写法
<?php
	/*
	 	连接数据库：操纵数据库
	 		* 写好配置信息
	 		* 检测是否连接成功
	 */
	//中文乱码
	header("content-type:text/html;charset=utf-8");
	//配置信息
	$servername = 'localhost';//主机名
	$username = 'root';//登陆数据库的用户名
	$password = '';//如果用wamp就是为空，用phpstudy 密码是 root
	$dbname = 'try';//数据库名称
	//创建数据库连接
	$conn = new mysqli($servername,$username,$password,$dbname);
	if ($conn->connect_error) {
        var_dump($conn->connect_error);
    }
	//设置编码:
	//乱码：编码方式不一致的时候，数据的来源(csv、xls)/数据的存储(数据库数据表)/php(接口)/html(前端页面)
	$conn->set_charset('utf8');
?>
    
总结：
1.可以新建php编写以上代码，在其他需要连接数据库的php编写：
header("content-type:text/html;charset=utf-8");
include 'connect.php';
2.或者直接在需要连接数据库的php上编写以上内容。
```

### 2.执行语句

时间默认值CURRENT_TIMESTAMP  默认显示增加数据时的时间

#### 数据操作

```js
增删改==>布尔值

插入数据
格式：insert into <表名> [(<字段名1>[,..<字段名n > ])] values ( 值1 )[, (值n )];
//单条数据
insert into MyGuests (firstname, lastname, email)
values ('John', 'Doe', 'john@example.com')

删除表数据
格式：delete from 表名 where 表达式
//删除MyGuests表中id为1的数据
DELETE FROM MyGuests where id=1;
//删除所有数据
DELETE FROM MyGuests

修改表中的数据
格式：update 表名 set 字段=新值,… where 条件;
update MyGuests set name='Mary' where id=1;


查询==>查询结果集（对象）

查询表中的数据
字段可用*代表全部字段
格式： select <字段1, 字段2, …> from < 表名 > where < 表达式 >;
//查看表 MyGuests 中所有数据
select * from MyGuests;
//查看表 MyGuests 中前10行数据：
select * from MyGuests order by id limit 0,10;

select一般配合where使用，以查询更精确更复杂的数据。
```

#### 条件控制语句

```js
WHERE 语句===>SELECT * FROM tb_name WHERE id=3;

相关条件控制符：
	=、>、<、<>、IN(1,2,3......)、BETWEEN a AND b
	AND、OR、NOT
    LIKE用法中
    	% 匹配任意、
		_ 匹配一个字符（可以是汉字）

        
LIMIT idx,qty：数量控制  从idx开始，取qty条  要放在后面
	SELECT * FROM goods LIMIT 2,5

IS NULL 空值检测

排序ORDER BY xxx asc/desc
	asc 升序（默认）
    desc 降序
//根据pic排序 降序
select * from MyGuests order by pic desc;
```

#### 读取数据

```js
SELECT…FROM，得到查询结果集
- num_rows ：得到查询结果集的长度，用于判断是否查询到结果
- fetch_all(MYSQLI_ASSOC) 返回查询结果集里的所有对象，返回一个数组
- fetch_assoc() 得到第一个结果，返回一个对象
- fetch_row()    得到第一条数据的值
```

### 3.关闭查询结果集

 获取查询结果集的变量->close();

### 4.关闭数据库

$conn->close();

### 5.mySQL语句返回值

```js
- 返回布尔值
  - insert
  - update
  - delete
- 返回查询结果集
  - select语句
```

## 导入数据

现在数据库建立好表，表的数据类型及编码都先定义好。再从其他文件导入进来

## 转储及运行数据库

先创建同名的数据库，右键运行数据库，重新进入界面才会看到



# 面向对象

## 一、创建对象及使用

​            1.创建对象
​            2.对对象进行描述   
​		有什么(属性)
​		能做什么（方法）
​            3.指挥对象做事情

## 二、对象的创建方式

1.字面量 {} 一般只用于创建单一对象
2.new Object() 一般只用于创建单一对象
​             工厂模式：1.将参数传入函数内，

​				2.函数内生成对象，

​				3.给对象设置属性及方法（具体值来自传入的参数），

​				4.最后将对象通过return返回出去。

```
		function createBuwawa(name,gender){
            var buwawa = new Object();
            buwawa.name = name;
            buwawa.gender = gender;
            buwawa.sajiao = function(){
                console.log("讨厌，小拳拳锤你胸口");
            };
            buwawa.liaohan = function(){
                console.log("爷，给妞笑一个");
            };
            return buwawa;
        }
        var peiqi = createBuwawa("佩奇","女");
```

​             优点:解决了重复创建多个同一类型对象的问题
​             缺点：没有解决对象识别的问题（对象的类型都是Object）。

3.自定义构造函数 
​             自定义构造函数与普通函数定义没有区别，唯一不同的是执行方式不同
​                 函数名()    ==>普通函数，若没有return，则返回值为undefined
​                 new 函数名()   ==>构造函数 
​             执行new构造函数时的四大步骤：
​                   1.在构造函数内部声明了一个对象
​                   2.将构造函数的this指向上面声明的对象
​                   3.给this绑定属性及方法，相当于给对象绑定
​                   4.将this对象返回出去

```
        function Yiwu(name,gender){
            // var peiqi = new Object();    隐藏声明对象peiqi
            // Yiwu.bind(peiqi);			隐藏将构造函数的this指向上面声明的对象
            this.name = name;
            this.gender = gender;
            this.sajiao = function(){
                console.log("不要998,只要0.998你就可以带回家，么么哒");
            }
            // return this;					隐藏将this对象返回出去
        }
        var  peiqi = new Yiwu("peiqi","女");
        console.log(peiqi);
        var  o2 = new Yiwu("qiaozhi","男");
        console.log(o2);
```

​             优点：
​                 解决了重复创建多个同一类型对象的问题
​                 解决了对象的识别问题
​             约定：构造函数定义时，首字母大写



## 三、this 函数的当前对象

1.函数自执行：this指的是执行函数的对象
 	（1）一般对象.函数(),this指的是前面的对象
 	（2）对象.函数(),this指的是前面的对象
2.事件驱动函数:this指的是函数绑定的元素对象
3.new 构造函数()的this指的就是当前实例对象

```
 		function show(){
            console.log(this);
        }
        window.show();//this==>window		   省略了对象调用的函数，this指的是window

        var obj = {};
        obj.show = show;
        obj.show();//this==>obj					对象.函数(),this指的是前面的对象

        setTimeout(function(){
            console.log(this);//window			对象.函数(),this指的是前面的对象
        })

        btn.onclick = function(){
            console.log(this);//this==>btn		事件驱动函数:this指的是函数绑定的元素对象
        }

        function Yiwu(name){					new 构造函数()的this指的就是当前实例对象
            // peiqi
            this.name = name;
            this.sajiao = function(){}
        }										
        var peiqi = new Yiwu("peiqi");//this:peiqi
        var qiaozhi = new Yiwu("qiaozhi");//this:qiaozhi
```

## 四、对象的组成部分

```
 1.构造函数 function 函数名(){通过this定义属性及方法}、
 
 2.实例对象 
    new 构造函数() 产生的对象称为实例对象
    实例对象能拷贝构造函数的所有属性及方法
    实例对象可以使用其原型对象的所有方法
    
 3.原型对象
   原型对象都拥有一个constructor属性(构造器)，指向构造函数
   构造函数通过prototype属性指向原型对象
   实例对象通过__proto__指向原型对象
		__proto__ 是火狐谷歌等浏览器的私有属性
		Object.getPrototypeOf(实例)； //ES5方式去获取
		
4.只要是写死的方法或属性都可以写在原型对象里。
		function Yiwu(name,age){		//构造函数
			this.name = name;
			this.age = age;
		}
		Yiwu.prototype.show = function(){		//原型对象的方法
				console.log(6666);
		}
		var peiqi = new Yiwu("peiqi",18);	//实例对象
		var qiaozhi = new Yiwu("qiaozhi",15);
		peiqi.show();						//实例对象调用原型对象的方法
		qiaozhi.show();
		//都会打印出666
		
5.只要对象的构造函数是同一个，其他的对象都能用构造函数的原型对象的方法

6.调用原型对象的函数方法
	实例对象.原型对象的函数方法
	例如：peiqi.show();

```

## 五、实际运用

 (一)解决方案:构造函数+原型对象
​		使用构造函数添加私有属性
​		使用原型对象添加共享方法
（二）优点：
​		实例对象都有自己的独有属性
​		实例共享了原型中的方法，最大限度的节省了内存
 		支持向构造函数传递参数

## 六、对象的属性特性

```
		// - configurable
        //   - 可配置性，表示能否修改属性特性
        // - enumerable
        //   - 可枚举性，表示能否通过for-in遍历得到属性
        // - writable
        //   - 可写性，表示能否修改属性的值
        // - value
        //   - 数据属性，表示属性的值。默认值为undefined
        // 1. 通过.或者[]给对象添加的属性，拥有的属性特性默认值都为true（除了value为具体的值）
        // 2. 给对象添加属性及属性特性的方法：Object.defineProperty(obj, property, descriptor)
           3。Object.defineProperties(object, descriptors) 给对象的所有属性设置属性特性
        //      * 拥有的属性特性默认值为false（除了value为具体的值）
        获取属性特性：
		Object.getOwnPropertyDescriptor(object, propertyname)

		获取对象的所有属性：
		Object.keys(object) 只获取到可枚举的属性
		Object.getOwnPropertyNames(object) 获取所有属性的名称（包含不能枚举的属性）
```

## 对象属性的遍历与判断

for…in

遍历对象中的所有可枚举属性, 无论该属性存在于实例中还是原型中
in

```
if(name in s1){
	//只要通过对象能够访问到属性就返回true, 无论该属性存在于实例中还是原型中
}
```

#### 对象.hasOwnProperty(属性)

- 检测一个属性是存在于对象本身中
  - 返回true，说明属性存在对象中
  - 返回false，说明属性不存在或在原型中

> 检测一个属性是否存在于原型中：!obj.hasOwnProperty(name) && (name in obj) 

## 重置原型对象

1.可以一次性给原型对象添加多个方法，但切断了与原来原型对象的联系

2.重置原型对象,改变了指向，原来指向的原型还存在

```
function Popover(){}
Popover.prototype = {
    show:function(){},
    hide:function(){}
}
Object.defineProperty(Popover.prototype,'constructor',{
    configurable:true,
    value:Popover
})

注意
	1。注意覆盖问题
	2。注意识别问题
```

## 内置原型对象

```
内置的构造函数，不要直接重置原型对象
使用内置原型可以给已有构造函数添加方法
- 数组/字符串/数字等方法调用原理
- 扩展内置方法
//判断原型对象是否存在方法 ，不存在 用给原型对象添加函数的方法添加
 if(!Array.prototype.norepeat){
            Array.prototype.norepeat = function(){
                return Array.from(new Set(this));
            }
        }
```

# 继承

属性访问规则（继承的原理）

```
1.现在当前对象（实例）查找，找到则返回

2.到对象的原型对象查找，找到则返回

3.到原型对象的原型对象查找，以此类推，直到找到Object的原型对象（终点），找到则返回

4.到终点还是找不到，则返回undefined，会报错 xx is not a function

实例对象的proto->其原型对象的proto->原型对象的的原型对象->....object的原型对象
```

### 原型链继承

```
核心：拿父类实例充当子类原型对象
缺点：
	无法继承构造函数中的属性
	创建子类实例时，无法向父类构造函数传参
	原型对象中存在多余的属性

实现子类实例能调用整条链上的方法

父类实例、构造函数
var Man = fucntion(){};
var tiantian = new Man();
充当子类原型对象的 父类实例的构造函数
var preson = function(){};
拿父类实例（new preson()）充当子类原型对象(Man.prototype)
Man.prototype=new preson();

```

## 借用构造函数

核心：借父类的构造函数来增强子类实例，相当于把父类的实例属性`复制`一份给子类实例

在子类构造函数中执行下面代码：

父类构造函数.call(this,父类构造函数的实参)

实现：子类实例能够拷贝父类构造函数中的所有属性

## 组合式继承

原型链继承方法+借用构造函数拷贝属性

```
1。继承属性：借用构造函数
	只在构造函数中定义属性
2。继承方法：原型链继承
	把所有的方法写入原型对象
3.组合继承是最常用的继承模式。

缺点（原型链继承法的缺点）：
	在原型对象中生成多余的属性
	多次执行父类构造函数
```

案例：

```
function Animal(jiaosheng){
            this.jiaosheng = jiaosheng;
        }
        Animal.prototype.eat = function(){console.log("吃")}
        function Dog(name,jiaosheng){
            // this:狗的实例对象
            //用call（）改变Animal函数的this指向为wangcai，并执行函数
            //借父类的构造函数来增强子类实例
            Animal.call(this,jiaosheng);  
            this.name = name;
        }
        Dog.prototype = new Animal();
        Dog.prototype.tian = function(){console.log("舔就对了")};
        Dog.prototype.fanzhi = function(){console.log("胎生")};
        var wangcai = new Dog("wangcai","旺");
```

## 原型式继承

核心：创建一个空的构造函数F，将子类原型对象指向F的实例对象，将F的原型对象执行父类的原型对象

解决原型链继承法的缺点：生成多余的属性

缺点 不能传属性

```
//创建一个空的构造函数F
function F(){};
//将子类原型对象指向F的实例对象
子类.prototype= new F();
//将F的原型对象执行父类的原型对象
F.prototype = animal.prototype;

//封装
function object(o){
    function F(){}
    F.prototype = o;
    return new F();
}
子类的原型对象 = object(父类的原型对象);
```

## 寄生组合式继承

原型式继承方法+借用构造函数拷贝属性

完美的继承方法

核心：

- 继承属性：借用构造函数
- 继承方法：原型式继承

```
用原型式继承写，在子类构造函数里写借用构造函数
```

## ES6继承

```
1.class定义类
 	写在类里面的方法实际是给Person.prototype添加方法
	 constructor方法是类的默认方法，相当于在构造函数内生成属性
2.extends继承
 	子类继承了父类，在子类构造函数中必须调用super方法(借用构造函数)
 	子类的constructor方法没有调用super之前，不能使用this关键字，否则报错，而放在super方法之后就是正确的。
3.静态方法
	如果在一个方法前，加上static关键字，这就称为“静态方法”
 	静态方法方法不会被实例继承，而是直接通过类来调用Person.getInfo()
 	父类的静态方法，可以被子类继承Man.getInfo()
```

例子：

```
		//用class定义类来定义构造函数
		class animal{
			//用constructor定义属性
			constructor(jiaos,age){
				this.jiaos = jiaos;
				this.age = age;
			}
			//方法直接写
			eat(){
				console.log('吃');
			};
		}
		//class 子类 extends 父类    子类继承父类
		class dog extends animal {
			constructor(name,jiaosheng,age){
				//super  把dog的参数传到animal的constructor上 跟借调一样
				//子类的constructor方法没有调用super之前，不能使用this关键字
				super(jiaosheng,age);
				this.name = name;
			}
			fanzhi(){
				console.log('孪生');
			};
			tian(){
				console.log('tiangou');
			}
		}
		var wancai = new dog('wangcai','wangcai',2);
```

## call和apply的使用

数据判断  typeof  判断引用数据类型都是返回objet

可以用Object.prototype.toSpring.call([]) 来判断  数组可换其他数据

返回[Object Array]

原理 ：  每个数据的原型对象有2个  toString方法 一个是自身的toString方法，一个是最终指向Object的原型对象的toSpring方法，数据会优先找离自身最近的方法使用，导致obj原型的方法无用，所以调用obj的原型的方法出来，再改this的指向为数据。

```
1。bind、call、apply都是函数的方法
	1.1 bind()改变函数中this的指向，返回新函数
    1.2 call()改变函数中this的指向,同时执行该函数
		 格式：父类构造函数.call(子类实例,父类参数1,参数2,参数3...)
	1.3 apply：改变函数中this的指向,同时执行该函数，函数的参数为数组
		 格式：父类构造函数.apply(子类实例,[参数1,参数2,参数3...])
	1.4 call与apply的唯一区别：传参方式不同，call多个参数，apply只有两个参数，第二个参数为数组

2。改变充当子类原型的父类实例的构造函数里的属性方法的this

3。将父类的构造函数拿到子类的构造函数中，改变this的执行，同时执行该函数,记得传参。

	解决了子类拷贝了父类的所有属性
	缺点：父类存在多余的属性

应用：
1.借用别人的方法：
 	 借用其他构造函数的原型对象中定义的方法
	 自己本身存在某个方法，但想使用原型链上其他原型对象的某个方法
	 //本身为一个伪类数组，用不了map方法
	var btn = document.querySelectorAll(".btn");
	//借用其他构造函数原型中的方法，用call改变指向为btn
    var arr = Array.prototype.map.call(btn,function(item){
     return item.value;
	 })
	  
2.利用apply方法，可以将参数转成数组传入
原来方法：
var res = Math.max（1,2,3,10,40,100,30,2,4）
apply方法：不修改指向，把参数用数组装起，再放进apply里
var arr = [1,2,3,10,40,100,30,2,4];
var res = Math.max.apply(null,arr);
```

# 闭包

1.概念：外函数内部嵌套内函数，同时将内函数返回。内部函数引入外部函数的变量及参数，不会被垃圾回收机制所收回

2.优缺点：
​            2.1	可以让一个变量长期驻扎在内存当中不被释放。过度使用闭包，会占用过多的内存，造成性能问题
​            2.2	避免全局变量的污染，闭包内的变量不会被函数外使用到

​	    2.3	私有成员的存在, 无法被外部调用, 只可以自己内部使用

3。结论

- 闭包是指有权访问另一函数作用域中的变量的函数
- 闭包，可以访问函数内部的局部变量，并让其长期驻留内存
- 由于闭包会携带包含它的作用域(运行环境)，因此会比其他函数占用更多内存，过度使用闭包可能会造成性能问题。

例子：

```
function aa(){
            var num = 10;
            function bb(){
                num++;
                console.log(num);
            }
            return bb;
        }
        var res = aa();
        res();//11
        res();//12
```

垃圾回收机制：局部变量函数用完后会自动销毁，释放内存

# jQuery

官方网站：http://jquery.com/

## 下载与安装

```js
- 官网下载
http://jquery.com/download/
- CDN
  - https://code.jquery.com/jquery-3.0.0.js
  - https://code.jquery.com/jquery-3.0.0.min.js
  - https://www.bootcdn.cn

```



## 基本使用

创建jq对象

```js
jQuery(选择器|dom节点，上下文对象)
	上下文对象：选择器、dom节点、jq对象
	jQuery("#output","#baba")
	jQuery(this)

length ==> 表示jq对象的长度，若为0，说明获取不到元素
```

延迟代码执行

```js
jQuery(function($){})
```

## dom节点与jq对象的转换

dom节点->jq对象 

```js
	jQuery(dom节点)
	$(dom节点)
```

jq对象->dom节点

```js
	$jq[索引]  | $jq.get(索引)
	get()不传参得到集合中所有的dom节点
```

## 选择器

基本选择器

```js
- ID选择器$(“#save”)
- 类选择器$(“.class”)
- 标签选择器$(“div”)
- 复合选择器 $(“div,span,p.myClass”)
- 属性选择器$(‘[id=box]’)
  - $(‘li[data-index]’):获取有data-index属性的所有元素
  - $(‘li[data-index!=10]’):data-index属性不等于10的元素,css目前未支持
  - $(‘li[data-index^=10]’):data-index属性以10开头的元素
  - $(‘li[data-index$=10]’):data-index属性以10结尾的元素
  - $(‘li[data-index*=10]’):data-index属性包含10的元素
```

表单选择器$(‘:input’)

```js
- :selected //获取已选择的option元素
- :submit //匹配所有提交按钮
- :reset //匹配所有重置按钮
- :button //匹配所有按钮
- :text //匹配所有的单行文本框
- :password //匹配所有密码框
- :checked //匹配所有被选中的元素(复选框、单选框等，select中的option)
- :checkbox //匹配所有复选按钮
- :radio //匹配所有单选按钮
```

可见性

```js
:hidden //匹配所有不可见元素(display:none)，或者type为hidden的元素
:visible //匹配所有可见元素

以上两个选择器配合is()方法通常用于判断，返回布尔值

if(box.is(':visible')){
    box.css('display','none');
}
```

## 筛选

### 筛选选择器

```js
:odd 、:even  、 :gt()、:lt()   ===>筛选范围（索引支持负数）  gt:大于;		lt:小于

:contains(奥巴马) ===> 筛选出包含“奥巴马”这三个字的元素
例如：$("#output li a:contains(嘻嘻嘻)")     筛选a标签里的嘻嘻嘻
```

### 筛选方法  $x.方法

```js
first()/last(): 获取集合中第一个/最后一个元素

eq(index|-index): 获取第N个元素,n支持负数（表示从后面查找）

filter(expr|obj|ele|fn): 筛选出与指定表达式匹配的元素集合。这个方法用于缩小匹配* 的范围。用逗号分隔多个表达式
	例子：缩小匹配范围  $('#output li').filter('.aa') 匹配全部li里类名是aa的 li
    
map(fn): 将一组元素转换成其他数组（不论是否是元素数组）

slice(start,[end]): 选取一个从start到end(不包括end)匹配的子集

has(expr|ele): 保留包含特定后代的元素，去掉那些不含有指定后代的元素。
	例子：$("#output li").has(".aa")  匹配li里 儿子的类名是aa的li
    
not(expr|ele|fn): 删除与指定表达式匹配的元素
```

## 查找

### 查找子元素

```js
	find(expr|obj|ele): 查找后代元素
	children([expr]): 取得匹配元素的所有子元素。(原生js:children)
```

### 查找父级元素

```js
	parent([expr]): 获取父元素
    
	parents([expr]): 取得所有父级元素
    
	closest(expr|obj|ele): 从元素本身开始，逐级向上级元素匹配，并返回最先匹配的元素
    
	offsetParent(): 返回第一个有定位属性(absolute,relative,fixed)* 的父元素,如果没有定位父级，则返回html元素
```

### 查找兄弟元素

```js
	next([expr]): 返回下一个同辈元素 ==> nextElementSibling

	prev([expr]): 获取前一个同辈元素 ==> previousElementSibling

	nextAll([expr]): 获取当前元素之后所有的同辈元素
    
	prevAll([expr]) 获取当前元素之前所有的同辈元素
    
	siblings([expr]) 获取当前元素的所有兄弟元素（除自身以外的所有兄弟元素 = * prevAll + nextAll）
```

## jQuery动画

### 基本动画效果

jQuery动画由三种预设速度slow,normal,fast（600，400，200）

显示隐藏：show()/hide()

```js
$xx.show(完成动画时间)改变元素的高、宽、不透明度，显示

$xx.hide(完成动画时间)改变高、宽、不透明度，直到0
```

滑动（通过改变高度）

```js
slideDown([完成动画时间,回调])   显示

slideUp([完成动画时间,回调])： 隐藏

slideToggle([完成动画时间,回调])  ===>隐藏时显示、显示时隐藏
```

淡入淡出（通过改变不透明度）

```js
fadeIn([完成动画时间])   显示

fadeOut([完成动画时间])   隐藏

fadeToggle([speed,callback])   显示、隐藏互相切换

fadeTo([[speed],opacity,[fn]])
	不断改变透明度opacity，直到设定的值，并在动画完成后可选地触发一个回调函数。
```

### 自定义动画

```js
animate (params,[speed],[fn])
	例如：$("img").animate({width:0},1000,function(){})

:animated   不常用
```

### 动画队列

```js
一个元素上的动画：
	当animate中存在多个属性时，动画同时发生
	当同一个元素链式调用animate时，动画是按顺序发生(队列)

不同元素上的动画：
	默认情况下，动画同时发生
	回调函数内的动画等到当前动画执行完后才接着执行
    
stop([clearQueue],[jumpToEnd])
	不加参数：停止当前元素所有《正在运行》的动画。
	- clearQueue:值为true时，清除队列
	- jumpToEnd:值为true时，跳到当前动画的最后一帧
    
delay(duration)
	设置一个延时来推迟执行队列中之后的动画。
	duration:延迟的时间
```

## DOM节点操作

### 增删改

#### 建jquery对象

```js
$('<div/>');

$('<div>生成一个div</div>');
```

#### 元素添加

```js
内部添加（添加为子元素）
	- append(content|obj|ele|fn): 在元素内部最后面追加内容（后置）
		var $dv = $('<div>hahaha</div>>')
		$('body').append($dv);
		父.append(子)
	- prepend: 往父元素内部添加第一个子元素
		$('body').prepend($dv);
		父.append(子)

	appendTo ===> $('<div>hahaha</div>>').appendTo($('body'))    作用同上
    子节点.appendTo(父节点) 
	prependTo ===> $('<div>hahaha</div>>').prependTo($('body'))     作用同上
    子节点.prependTo(父节点) 
        
外部插入内容（添加为兄弟元素）
	after: 在元素后面插入内容  ===> $('p').after($dv)  dv插到p后
	before: 在元素前面插入内容 ===> $('p').before($dv)	dv插到p前
		
	insertAfter ===> $('<div>hahaha</div>>').insertAfter($(dv))  hahah插到dv后
	insertBefore ===> $('<div>hahaha</div>>').insertBefore($(dv)) hahah插到dv前
		
	如果页面上已经存在了要添加的元素，append,prepend,after,before会把元素移动到页面相应的位置
```

#### 元素删除

```js
remove(); 删除元素, 虽然元素从文档中删除了，但js内部依然保留对它引用
	$('p').remove()    删除自身
    
empty(); 清空内容
	$('p').empty()
```

#### 元素复制

```js
clone([Event[,deepEvent]])
	Event  ：true  false    ；   是否复制元素的行为、事件，默认false
	deepEvent：true   false；默认跟随Event的值，是否复制子元素的行为、事件
```

### 盒模型属性

```js
.offset()
	获取匹配元素相对于根元素的偏移量
	返回一个对象，包含当前元素的top,left值

position()
	获取匹配元素相对(有定位属性)父元素的偏移量
	如果没有定位父级，则相对于根元素(html)，返回一个对象
	包含当前元素的top,left值。

width(v) = width
	取值/赋值,当传入v时，相当于css(‘width’,v);

innerWidth() = width + padding; <==> clientWidth

outerWidth() = width + padding + border; <==> offsetWidth

outerWidth(true) = width + padding + border + margin;
```

## 事件

### jquery事件绑定与移除

```js
on(type,[selector],fn)
	selector: 把本来绑定给selector的事件委托给它的父级，可改变函数this指向为selector
    
	事件命名空间, 自定义事件（对事件加以细分）
		格式：事件类型.自定名字
		例如   $().on('click.zz',fn)

	一次性绑定多个事件，事件之间以空格隔开
		例如   $().on('click.zz',fn fn fn)

	支持自定义事件的绑定
		$(ele).on('laowang',function(){})
		触发自定义事件：$(ele).trigger(‘laowang’);


off: 清除绑定事件
	- off(‘click’);//清除当前元素的点击事件

	- off();//清除当前元素所有事件

	- off(‘click mouseover’) 一次性清除多个事件，事件之间以空格隔开
    
	- off(‘click.output’) 清除命名空间事件
    
	可以给同类型事件命名，清除时可用名字单独清除
```

### 其他事件方法

```js
hover(enter[,leave])
	- enter:鼠标移入时执行,写fn
	- leave:鼠标移出时执行,写fn
	hover方法内部使用mouseenter + mouseleave来实现效果

trigger(type): 手动触发事件（即使事件没有发生，也能执行事件处理函数）

triggerHandler(type): 这个方法会触发指定的事件类型上所有绑定的处理函数。但不会执行浏览器默认行为，也不会产生事件冒泡

阻止浏览器默认行为 ===> event.preventDefault();
	
阻止事件传播 ===> event.stopPropagation();
	
两者一起阻止： ===> return false;
```

## ajax

### jQuery的ajax方法

```js
- $.ajax(settings)
  - type:请求类型，默认GET
  - url:数据请求地址（API地址）
  - data:发送到服务器的数据对象，格式：{Key:value}。
  - success:请求成功时回调函数。
  - dataType:设定返回数据的格式，json, jsonp, text(默认), html, xml, script
  - async：是否为异步请求，默认true
  - headers:一个额外的"{键:值}"对映射到请求一起发送
  - jsonp:在一个jsonp请求中重写回调函数的名字,例如 cb /callback

- $.get(url,[data],[fn],[dataType]) // type:’get’

- $.post(url,[data],[fn],[dataType]) // type:’post’

- $.getJSON(url,[data],[fn]) // type:’get’, dataType:’json’

- $.getScript(url,[callback]) // type:’get’, dataType:’script’

- load(url,[data],[callback]) 载入远程 HTML 文件代码并插入页面中。

```

## 常用jQuery原型对象的方法

```js
css(attr[,val]): 获取/改变元素style属性（内联样式）
- 取值：css(attr),css([‘color’,’text-align’]) <==> getComputedStyle[attr]
- 赋值：css(attr,val),css({attr:val});
```

```js
val(v): 获取/设置匹配表单元素的值（等同于原生js中的value属性）
取值：input.val()     赋值：input.val(v)
v可以为 
-字符串 
-数组（一般用于单选/复选框的勾选） 
-函数function(idx,val){ return 值}//函数内部一定要返回值
```

```js
html(): （等同于原生js中的innerHTML）
取值div.html()：取得第一个匹配元素的html内容
赋值div.html(‘:’)：设置匹配元素的内容
```

```js
text(): 取得所有匹配元素的文本内容。
```

```js
addClass()/removeClass(): 添加/删除类,支持多个类同时添加或删除,空格分开
- toggleClass(): 如果存在（不存在）就删除（添加）类。
- hasClass(‘con’): 判断当前元素是否包含con这个类，返回布尔值（不支持多个类进行判断）
```

```js
eq(n) 获取第N个jquery对象（元素）,n支持负数（表示从后面查找）
```

```js
index():获取当前元素在同辈元素中的索引值
$(this).index();
```

```js
显示/隐藏
- show()：显示元素
- hide()：隐藏元素
  - 带参数：同时改变width,height,opacity的动画
```

```js
is(expr|obj|ele|fn) 
根据选择器、DOM元素或 jQuery 对象来检测匹配元素集合，
其中如果有一个元素符合这个给定的选择器表达式就返回true。
如果没有元素符合，或者表达式无效，都返回false。
```

```js
attr(name[,val]) 设置/获取html标签属性
```

```js
prop(attr[,val]) 获取/设置DOM节点属性（一般修改布尔类型属性）
- 获取：获取在匹配的元素集中的第一个元素的属性值。
- 赋值：给集合中所有元素属性赋值
val为函数
$(':checkbox').prop('checked',function(idx,oldVal){
    return !oldVal;
}
```

```js
each(function(idx,ele){}) //用于遍历jquery对象
- return true;// 跳过当前循环，进入下一个循环（等效原生js中得continue）
- return false;// 退出整个each循环（等效原生js中得break）
```

## 常用jQuery静态方法

```js
$.each(arr|obj,callback)：通用遍历方法，用于遍历对象和数组。
- callback(idx,item)
```

```js
$.map(arr|obj,callback)：根据现有数组生成一个新的数组，新数组的元素为callback内return的值
- callback(item,idx)
```

```js\
$.type(n)：检测参数n的数据类型 ==> 跟typeof类似
```

```js
$.makeArray(obj) //将类数组对象转换为数组。
```

```js
$.parseJSON(json) //接受一个JSON字符串，返回解析后的对象。类似原生js中的JSON.parse
```

```js
$.inArray(value,array,[fromIndex]) 
//确定value在数组array中的位置，从0开始计数(如果没有找到则返回 -1 )，一般用于判断数组中是否包含某一字符。
```

```js
serialize()/serializeArray() : 只能在form表单中使用，并且表单元素必须有name属性
```

# 插件

## 常用插件

```js
- jqueryUI //官方插件，功能多且全面，官网：www.jqueryui.com

- jquery.validation //表单验证插件,官网：https://jqueryvalidation.org/

- jquery.easyUI //是一组基于jQuery的UI插件集合,Demo：http://www.jeasyui.net/

- bootstrap //是最受欢迎的 HTML、CSS 和 JS 框架，用于开发响应式布局、移动设备优先的 WEB 项目，官网：http://v3.bootcss.com/

- highcharts ===> https://www.hcharts.cn/

- swiper ===> https://www.swiper.com.cn/
```

# Git

Git是一个开源的**分布式**版本控制系统

下载地址：<https://git-for-windows.github.io>

## 配置个人信息（名字与邮箱）

```js
使用Git的第一件事就是设置你的名字和email,这些就是你在提交commit时的签名
git config --global user.name "Your Name"
git config --global user.email "email@example.com"
查看是否配置成功，用命名git config -l
```

## git的使用（命令行）

### 创建本地仓库

```js
git init：把当前目录变成一个git仓库，并自动创建master分支
该命令会在目录下创建一个.git的隐藏文件夹，这就是git的本地仓库，生成.git的目录称为工作区，所有工作区包含一个git仓库，git仓库包含一个暂存区和版本库
```

### 添加文件到版本库的步骤

1. 创建（修改）文件
   往工作区中添加/修改文件
2. 添加到暂存区：

```js
git add 文件夹 ===> 把文件夹下的所有修改添加到暂存区
git add . ===> 添加所有修改到暂存区
```

   3.提交到版本库：

```js
git commit -m "备注" ===> 每次提交都会自动生成一个commit id
如果不写-m回车会进入vim编辑界面，退出方法：
- 进入编辑状态：i
- 退出编辑状态：ESC
- 同时按下Shift和冒号（:），接着输入输入：q（退出不保存），wq（保存并退出）
```

### 其他辅助命令

```js
查看仓库变更状态： git status
用status查看仓库会有几种状态：untracked、unstaged、uncommitted 
```

![仓库变更状态](H:\web学习资料\2阶段资料\二阶段\javascript\day7-3Git\doc\img\gitstatus.png)

## git远程仓库

- github(国外):<https://github.com/>
- coding(国内):<https://coding.net>

### 关联本地仓库与远程仓库

```js
有两种方式关联：ssh和https两种协议，https比较简单，但提交时每次都分输入用户名和密码，
如使用https协议，直接跳过以下第1、第2步
```

1.创建SSH Key

```js
ssh-keygen -t rsa -C 'email地址'
以上命令会在当前window用户的目录里创建.ssh目录，里面有id_rsa（私钥）和id_rsa.pub（公钥）两个文件
C:\Users\Administrator.ssh
```

2.添加SSH Key到Git服务器 

```js
将公钥写到github的ssh keys 上,头像-setting-sshkey
添加完成后测试线路是否连通：ssh -T git@github.com
```

3.建立本地仓库与远程仓库的连接

```js
方式1：适用于先有本地仓库，后有远程仓库的情况
格式：
git remote add 远程仓库名 远程仓库地址

git remote add origin git@github.com:xxx/view.git

测试是否成功git remote -v

删除远程仓库连接：git remote remove 远程仓库名


方式2：克隆（适用于先有远程库，后有本地仓库的情况）
格式：

git clone 远程仓库地址

当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了
，并且，远程仓库的默认名称是origin
```

### 推送到远程仓库

```js
git push
- 格式：
git push 远程仓库名 本地分支名:远程分支名
git push origin master

把本地分支内容推送到远程分支（远程分支名省略表示推送到与本地分支相同的分支）
```

### 拉取与合并

同步本地与远程仓库

```js
- git pull
  格式：
git pull 远程仓库名 远程分支名:本地分支名
git pull origin master      
      
拉取远程分支内容到本地并与本地分支进行合并（本地分支名省略表示合并到与远程分支名相同的分支）

git pull的时候,提示fatal: refusing to merge unrelated histories 
解决方法:git pull origin master --allow-unrelated-histories

- git fetch
拉取远程分支内容
- git merge
合并分支内容
- git merge --abort
放弃合并分支

git pull origin master

//以上命令相当与以下命令等效
git fetch origin master
git merge origin/master

push和pull后的分支顺序格式：<来源地>:<目的地>
```

## 版本回退

```js
回退命令：

git reset

- 回退到上一个版本
git reset --hard HEAD^
- 回退到指定版本：(常用这种方法)
git reset --hard [commit id] 版本号没必要写全，前几位就可以了，Git会自动去找。
- 回退指定文件
git reset --hard [commit id] <file>
- 参数说明
  - –hard:工作区、暂存区、版本库的文件同时回退
  - –mixed：暂存区、版本库的文件回退（默认）
  - –soft：仅仅回退版本库中的文件
```

```js
显示从最近到最远的提交日志：

git log

- –pretty=oneline（显示简要信息id+备注）
- –graph（图形显示版本走向）
- –abbrev-commit（显示简写的id）
- 一大串类似3628164…882e1e0的是commit id（版本号）
```

```js
查看命令历史：git reflog
```

```js
- 撤销文件修改
  - git checkout -- <file>：放弃工作区的修改
  - git rm --cache <file>：撤销暂存区的修改
  - git reset HEAD <file>：撤销暂存区的修改
- 对比文件：git diff <file>
```

## git过滤配置(过滤清单)

在文件根目录创建文件".gitignore",告诉git哪些文件不用提交到版本管理中

```js
#过滤node_modules根目录下的文件（不过滤其他目录下的node_modules文件夹）
/node_modules

#过滤所有mtk文件夹
mtk/ 

#过滤所有.zip文件
*.zip 
*.mp3
*.mp4

#过滤某个具体文件
/mtk/do.c 
```

#为注释

演示sass遗留的依赖包问题：npm init创建package.js，npm install根据package.js下载包

## 分支操作（了解）

```js
- 创建分支：git branch 分支名

- 切换分支：git checkout 分支名
  以上两步合并为：git checkout -b 分支名
  
- 查看分支：git branch
列出所有分支，当前分支前面会标一个*号

- 查看远程分支：git branch -r

- 合并分支： git merge 分支名
  - git merge dev：把dev分支合并到当前分支
  - Fast-forward：快速合并
    禁用快速合并： –no-ff （保持分支信息）
    合并要创建一个新的commit，所以加上-m参数，把commit描述写进去

- 删除分支：git branch -d 分支名
强行删除，需要使用命令git branch -D feature-vulcan

- 获取远程分支
  1. 先获取（git fetch）
  2. 然后在本地创建一个同名分支,并将远程分支映射到此分支（git branch dev origin/dev）

```

## 实际开发

**在实际开发中，我们应该按照几个基本原则进行分支管理：**
首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；

那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；

你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。

# SVN

**集中式**代码管理版本控制系统

## 服务器安装

下载：<https://www.visualsvn.com/downloads/>

## 客户端安装

下载：<https://tortoisesvn.net/downloads.zh.html>

## 客户端使用

```js
基本操作
1.安装客户端
2.获取远程仓库(服务器)内容
	2.1.拿到服务器仓库地址（URL of repository）
    2.2.获得用户名密码
    2.3.在文件夹空白处右键，点击SVN checkout，输入仓库地址和存放文件的地址
    2.4.输入账户名密码
		2.4.1.如果存在旧用户名密码，右键，tortoise SVN，Setting，点击Saved Data 
        2.4.2.点击Authentication data选项右侧的Clear all 清除用户名密码
        2.4.3.再重复2.3   2.4步骤
3.更新（SVN Update）：同步文件
当迁出相应目录后，如果他人对服务器上此目录内容进行了修改，则需要再次获取改动内容到本地目录的过程称为更新

4.提交(SVN Commit)：把本地修改提交到服务器
每次提交前，都要先Update一下，确保更新到服务器最新版本后再提交

填写关于本次更新的日志（log message），这是必填项，否则commit会失败
每成功提交一次，SVN版本号自动加1
```

## 服务器使用

```js
1.创建仓库：visual SVN- manager管理者-repositories仓库-create new repositories

2.读写许可   
仓库名右键-properties-add-create user-设置许可

3.改变用户
文件夹右键-tortoise-setting-saved Data-Authentication-clear all

4.updata to version 版本回退

5.get locked 锁住就不能修改

6.报错（is already locked）-clear up-breaks write locaks勾上

7.解决冲突
冲突文件-//里面的东西都删除-保留你需要留下来的
把冲突报错文件删掉
svn commit 
svn update
```

## 其他操作

```js
-增加文件(Add)
-检查更新（Check for modifications）
-删除文件（Delete）
-撤销更改（Revert）
-锁定和解锁（Get lock and Release lock）
当项目需要时可以在本地硬盘中将迁出的内容进行锁定，选中要被锁定的文件右键选择“Tortoise SVN”的“Get lock…”项进行锁定（锁定后他人将无法修改此文件），系统弹出锁定信息框。 当文本文件锁定后，需要通过解锁他人才能继续对文件进行修改。
-重命名文件（Rename）
-获取历史文件（Show log）
```

## 利用SVN管理代码一天的工作流程

```js
1.从服务器下载项目组最新代码。
2.然后进行工作，每隔一段时间向服务器自己的分支提交一次代码。
3.下班时间快到了，把自己的代码合并到服务器上，一天的工作完成。
```

# Gulp

gulp是当下最流行的自动化工具 ，可以自动化完成我们开发过程中大量的重复工作

- 官网：<http://gulpjs.com/> 
- 中文网：<http://www.gulpjs.com.cn/> 

## gulp的安装及运行

### 1.全局安装 gulp：

```js
npm install --global gulp    //全局安装gulp目的是为了通过它执行gulp任务
```

### 2.本地安装gulp：

```js
npm install gulp //不会自动生成在package.json
npm install --save gulp
npm install --save-dev gulp //本地安装gulp是为了调用gulp插件的功能
–save-dev 保存配置信息至 package.json 的 devDependencies 节点
- 这步操作前先新建package.json文件（npm init）
- 这步完成后就可以安装各种gulp插件了
```

### 3.安装gulp插件

```js
大部分插件都可以在http://www.npmjs.com找到，任何插件的使用都要经历以下三步：

安装插件：npm
npm install  gulp-htmlmin

PS：可一次性安装多个插件，插件间用空格隔开
```

#### 常用gulp插件:

```js
html压缩：gulp-htmlmin

css压缩：gulp-clean-css

js压缩：gulp-uglify

合并文件：gulp-concat

文件重命名：gulp-rename

编译Sass: gulp-sass

编译 Less：gulp-less
```

#### 其他常用插件

```js
- 浏览器同步测试：browser-sync
- 创建node服务器：http-server 

npm install -g http-server
```

### 4.创建gulpfile.js文件（gulp任务）

项目根目录下 创建gulpfile.js文件

gulp项目的配置文件，内容如下：

```js
//具体代码在npm网站查找
var gulp = require('gulp');
gulp.task('任务名', function() {
  // 将你的默认的任务代码放在这
});
```

### 5.运行 gulp：

在命令行执行以下命名，如果不写任务名称，则自动运行default任务（如果有）

```js
gulp <任务名称>
```

## gulp工作流程

```js
1. 选通过gulp.src(globs) 方法获取到想要处理的文件，并返回文件流
2. 然后文件流通过 pipe 方法导入到 gulp 的插件中
3. 经过插件处理后的文件流，再通过pipe方法导入到 gulp.dest() 方法中
4. 最后通过gulp.dest() 方法把流中的内容写入到文件中

PS：文件流=>文件在内存中的状态

5.监听文件修改，并执行相应任务gulp.watch(glob,[‘任务名’])
```

## globs语法

```js
globs需要处理的源文件匹配符路径，语法如下

- 匹配单个文件：
gulp.src('src/js/index.js')
- 匹配多个文件：
gulp.src(['src/js/index.js','src/js/detail.js']) //多个文件以数组形式传入
- 匹配所有文件
gulp.src('src/js/*.js')
- 匹配符：
!：排除文件，
      gulp.src(["./src/sass/**/*.scss","!./src/sass/var.scss"])
  *：匹配所有文件，
**：匹配0个或多个子文件夹，
{}：匹配多个属性

备注：若想实现某个文件不受匹配控制，在文件名前面加_
```

# Sass->css

SASS是一个 CSS 扩展语言解析器



